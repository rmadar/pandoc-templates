<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Romain Madar" />
  <meta name="date" content="2018-02-14" />
  <title>Example of two notebooks converted into a PDF document</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px solid #a0a0a0; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #1f1c1b; background-color: #ffffff; }
code > span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code > span.dt { color: #0057ae; } /* DataType */
code > span.dv { color: #b08000; } /* DecVal */
code > span.bn { color: #b08000; } /* BaseN */
code > span.fl { color: #b08000; } /* Float */
code > span.cn { color: #aa5500; } /* Constant */
code > span.ch { color: #924c9d; } /* Char */
code > span.sc { color: #3daee9; } /* SpecialChar */
code > span.st { color: #bf0303; } /* String */
code > span.vs { color: #bf0303; } /* VerbatimString */
code > span.ss { color: #ff5500; } /* SpecialString */
code > span.im { color: #ff5500; } /* Import */
code > span.co { color: #898887; } /* Comment */
code > span.do { color: #607880; } /* Documentation */
code > span.an { color: #ca60ca; } /* Annotation */
code > span.cv { color: #0095ff; } /* CommentVar */
code > span.ot { color: #006e28; } /* Other */
code > span.fu { color: #644a9b; } /* Function */
code > span.va { color: #0057ae; } /* Variable */
code > span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code > span.op { color: #1f1c1b; } /* Operator */
code > span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code > span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code > span.pp { color: #006e28; } /* Preprocessor */
code > span.at { color: #0057ae; } /* Attribute */
code > span.re { color: #0057ae; } /* RegionMarker */
code > span.in { color: #b08000; } /* Information */
code > span.wa { color: #bf0303; } /* Warning */
code > span.al { color: #bf0303; font-weight: bold; } /* Alert */
code > span.er { color: #bf0303; text-decoration: underline; } /* Error */
code > span. { color: #1f1c1b; } /* Normal */
  </style>
  <link rel="stylesheet" href="/home/rmadar/Documents/work/Meetings/2018-07-27-SUSY2028/MyNotes/pandoc-templates/templates/webstyle_template.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Example of two notebooks converted into a PDF document</h1>
<h1 class="subtitle">Notebook conversion from markdown using pandoc</h1>
<h2 class="author">Romain Madar</h2>
<h3 class="date">2018-02-14</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#regression-using-gaussian-processes"><span class="toc-section-number">1</span> Regression using gaussian processes</a><ul>
<li><a href="#introduction-to-gaussian-processes"><span class="toc-section-number">1.1</span> Introduction to gaussian processes</a></li>
<li><a href="#importation-of-the-usual-packages"><span class="toc-section-number">1.2</span> Importation of the usual packages</a></li>
<li><a href="#definition-of-the-kernel"><span class="toc-section-number">1.3</span> Definition of the kernel</a></li>
<li><a href="#priors-functions"><span class="toc-section-number">1.4</span> Priors functions</a></li>
</ul></li>
<li><a href="#dark-matter-coupled-to-top-quark"><span class="toc-section-number">2</span> Dark Matter Coupled to Top Quark</a><ul>
<li><a href="#general-informations"><span class="toc-section-number">2.1</span> General informations</a><ul>
<li><a href="#the-model"><span class="toc-section-number">2.1.1</span> The model</a></li>
<li><a href="#simplifications"><span class="toc-section-number">2.1.2</span> Simplifications</a></li>
<li><a href="#relevant-processes-and-final-states"><span class="toc-section-number">2.1.3</span> Relevant Processes and Final States</a></li>
<li><a href="#analytical-expressions"><span class="toc-section-number">2.1.4</span> Analytical Expressions</a></li>
</ul></li>
<li><a href="#numerical-analysis"><span class="toc-section-number">2.2</span> Numerical analysis</a><ul>
<li><a href="#general-informations-1"><span class="toc-section-number">2.2.1</span> General informations</a></li>
<li><a href="#mediator-width-as-function-of-its-mass"><span class="toc-section-number">2.2.2</span> Mediator width as function of its mass</a></li>
<li><a href="#mediator-width-and-invisible-br-function-sm-coupling"><span class="toc-section-number">2.2.3</span> Mediator width and invisible BR: function SM coupling</a></li>
<li><a href="#mediator-width-and-invisible-br-function-of-both-couplings"><span class="toc-section-number">2.2.4</span> Mediator width and invisible BR: function of both couplings</a></li>
<li><a href="#mediator-couplings-as-function-of-invisible-br-and-width"><span class="toc-section-number">2.2.5</span> Mediator couplings as function of invisible BR and width</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="regression-using-gaussian-processes"><span class="header-section-number">1</span> Regression using gaussian processes</h1>
<p>The material I used to build up this short tutorial can be found in http://katbailey.github.io/post/gaussian-processes-for-dummies/ (where the code were adapated from) and in this short lecture which gives a mathematical simplified (and intuitive) approach https://emtiyaz.github.io/pcml15/gp_by_carlos.pdf.</p>
<h2 id="introduction-to-gaussian-processes"><span class="header-section-number">1.1</span> Introduction to gaussian processes</h2>
<p>Gaussian processes (GP) is a statistical method allowing to interpolate measurements <span class="math inline">\(\boldsymbol{y}=\{y_i\}\)</span> made at points <span class="math inline">\(\boldsymbol{x}=\{x_i\}\)</span>. The basica idea is to assume that each <span class="math inline">\(y_i\)</span> is a random variable with a gaussian probability density function (PDF). Once the correlation matrix <span class="math inline">\(K = \{K_{ij}\} \equiv \{\mathcal{K}(x_i,x_j)\}\equiv \mathcal{K}(\boldsymbol{x},\boldsymbol{x})\)</span> is specified, where <span class="math inline">\(\mathcal{K}(x,x&#39;)\)</span> is called the kernel, the joint PDF (or multi-dimentional PDF) for all <span class="math inline">\(\{y_i\}\)</span> can be fully written: <span class="math display">\[
\text{PDF}(\boldsymbol{y}) \; = \; \mathcal{G}_{n}(\boldsymbol{x} ; \boldsymbol{\mu}, K)\; = \; \frac{1}{\sqrt{\text{det}(2\pi \,K)}} \; \text{exp} \left( \frac{1}{2} \, (\boldsymbol{x}-\boldsymbol{\mu})^{\text{T}} \, K^{-1} \, (\boldsymbol{x}-\boldsymbol{\mu}) \right)  \; \equiv \; \mathcal{N}(\boldsymbol{\mu},K)
\]</span></p>
<p>The game is then to predict the one dimensional gaussian PDF of an additional measurement to come <span class="math inline">\(y^*\)</span> at a point <span class="math inline">\(x^*\)</span>, knowing all the previous measurements (training samples) and assuming how each measurement at <span class="math inline">\(x\)</span> will impact the measurement in <span class="math inline">\(x&#39;\)</span> (encoded by the kernel).</p>
<p>By expliciting the two sub-spaces, one generated by <span class="math inline">\(\boldsymbol{x}\)</span> (and <span class="math inline">\(\boldsymbol{y}\)</span>) and the other generated by the measurement to be predicted <span class="math inline">\(\boldsymbol{x^*}\)</span> (and <span class="math inline">\(\boldsymbol{y^*}\)</span>), it becomes easy to write the joint PDF of <span class="math inline">\((\boldsymbol{y},\boldsymbol{y^*})\)</span>: <span class="math display">\[
\text{PDF}\left(
  \begin{bmatrix}
    \boldsymbol{y}  \\
    \boldsymbol{y^*}
  \end{bmatrix}
  \right)
\; = \; \mathcal{N}\left(\boldsymbol{\mu},
\begin{bmatrix}
  \mathcal{K}(\boldsymbol{x},\boldsymbol{x}) &amp; \mathcal{K}(\boldsymbol{x},\boldsymbol{x^*}) \\
  \mathcal{K}(\boldsymbol{x^*},\boldsymbol{x}) &amp; \mathcal{K}(\boldsymbol{x^*},\boldsymbol{x^*})
\end{bmatrix}
\right)
\]</span></p>
<p>which leads to the one dimensional gaussian PDF for the new value to be predicted <span class="math inline">\(\text{PDF}(\boldsymbol{y^*}) = \mathcal{N}(\mu^*,\Sigma)\)</span> with <span class="math inline">\(\mu^*\)</span> and <span class="math inline">\(\Sigma\)</span> are perfectly detmined by the kernel, the previous measurements (<span class="math inline">\(\boldsymbol{x}\)</span> and <span class="math inline">\(\boldsymbol{y}\)</span>) and the points where new measurements need to be predicted <span class="math inline">\(\boldsymbol{x^*}\)</span>:</p>
<p><span class="math display">\[
\boldsymbol{\mu^*} \; = \; \mathcal{K}(\boldsymbol{x^*},\boldsymbol{x})^{-1} \mathcal{K}(\boldsymbol{x},\boldsymbol{x}) \:\boldsymbol{y}
\]</span></p>
<p><span class="math display">\[
\Sigma \; = \; \mathcal{K}(\boldsymbol{x^*},\boldsymbol{x^*}) \: - \: \mathcal{K}(\boldsymbol{x^*},\boldsymbol{x})\mathcal{K}(\boldsymbol{x},\boldsymbol{x})^{-1}\mathcal{K}(\boldsymbol{x},\boldsymbol{x^*})
\]</span></p>
<h2 id="importation-of-the-usual-packages"><span class="header-section-number">1.2</span> Importation of the usual packages</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> matplotlib        <span class="im">as</span> mpl
<span class="op">%</span>matplotlib inline

<span class="co"># Plot settings</span>
mpl.rcParams[<span class="st">&#39;legend.frameon&#39;</span> ] <span class="op">=</span> <span class="va">False</span>
mpl.rcParams[<span class="st">&#39;legend.fontsize&#39;</span>] <span class="op">=</span> <span class="st">&#39;xx-large&#39;</span>
mpl.rcParams[<span class="st">&#39;xtick.labelsize&#39;</span>] <span class="op">=</span> <span class="dv">16</span>
mpl.rcParams[<span class="st">&#39;ytick.labelsize&#39;</span>] <span class="op">=</span> <span class="dv">16</span>
mpl.rcParams[<span class="st">&#39;axes.titlesize&#39;</span> ] <span class="op">=</span> <span class="dv">18</span>
mpl.rcParams[<span class="st">&#39;axes.labelsize&#39;</span> ] <span class="op">=</span> <span class="dv">18</span>
mpl.rcParams[<span class="st">&#39;lines.linewidth&#39;</span>] <span class="op">=</span> <span class="fl">2.5</span>

<span class="co"># Define global paramter to build fake data</span>
n<span class="op">=</span><span class="dv">100</span>
xmin<span class="op">=</span><span class="dv">0</span>
xmax<span class="op">=</span><span class="dv">4</span></code></pre></div>
<h2 id="definition-of-the-kernel"><span class="header-section-number">1.3</span> Definition of the kernel</h2>
<p>The kernel specifies how two points in the feature space <span class="math inline">\(x\)</span> and <span class="math inline">\(x&#39;\)</span> will be influence each other. There are several possibilities depending on which type or probleme need to be solve. The next piece of code define a function which plot the 1D and 2D plot of the correlation matrix obtained for any kernel function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Plot Kernel function</span>
<span class="kw">def</span> plot_kernel_function(x, Kij, kernel_name<span class="op">=</span><span class="st">&#39;&#39;</span>):
    plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>,<span class="dv">5</span>))
    plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)
    plt.title(<span class="st">&#39;1D kernel&#39;</span><span class="op">+</span>kernel_name)
    plt.plot( x, Kij[:,<span class="bu">int</span>(n<span class="op">/</span><span class="dv">2</span>)] , <span class="st">&#39;o-&#39;</span> )
    plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)
    plt.title(<span class="st">&#39;2D kernel&#39;</span><span class="op">+</span>kernel_name)
    plt.imshow( Kij , extent<span class="op">=</span>[xmin,xmax,xmin,xmax], aspect<span class="op">=</span><span class="st">&#39;auto&#39;</span>, origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)
    plt.colorbar()
    plt.tight_layout()
    <span class="cf">return</span></code></pre></div>
<p>Four examples of usual kernel are implemented and defined below:</p>
<p><span class="math display">\[
\text{Radial-basis function} : \mathcal{K}(x_i,x_j) = \text{exp}\left( {\frac{(x_i-x_j)^2}{2\ell^2}} \right)
\]</span></p>
<p><span class="math display">\[
\text{Rational Distance} :\mathcal{K}(x_i,x_j) =  \left( 1 + \frac{(x_i-x_j)^2}{\alpha \ell^2} \right)^{-\alpha}
\]</span></p>
<p><span class="math display">\[
\text{Dot product} : \mathcal{K}(x_i,x_j) = \sigma + x_i \cdot x_j 
\]</span></p>
<p><span class="math display">\[
\text{Exponential sinus squared} : \mathcal{K}(x_i,x_j) = \text{exp}\left(-2\times \sin\left(\frac{\pi}{p} \frac{x_i-x_j}{\ell}\right)^2 \right) 
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Exponential square distance kernel</span>
<span class="kw">def</span> kernel_ESD(a, b, param):
    sqdist <span class="op">=</span> np.<span class="bu">sum</span>(a<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>) <span class="op">+</span> np.<span class="bu">sum</span>(b<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.dot(a, b.T)
    <span class="cf">return</span> np.exp(<span class="op">-</span>.<span class="dv">5</span> <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span>param<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> sqdist)

<span class="co"># Define the rational quadratic kernel</span>
<span class="kw">def</span> kernel_RQ(a, b, param):
    alpha<span class="op">=</span>param[<span class="dv">0</span>]
    l<span class="op">=</span>param[<span class="dv">1</span>]
    sqdist <span class="op">=</span> np.<span class="bu">sum</span>(a<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>) <span class="op">+</span> np.<span class="bu">sum</span>(b<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.dot(a, b.T)
    <span class="cf">return</span> np.power(<span class="dv">1</span> <span class="op">+</span> sqdist<span class="op">/</span>(l<span class="op">*</span>alpha), <span class="op">-</span><span class="dv">1</span><span class="op">*</span>alpha)

<span class="co"># Define the dot product kernel</span>
<span class="kw">def</span> kernel_DP(a, b, param):
    <span class="cf">return</span> param <span class="op">+</span> np.dot(a,b.T)

<span class="co"># Define the Exp-Sine-Squared kernel</span>
<span class="kw">def</span> kernel_ESS(a, b, param):
    p<span class="op">=</span>param[<span class="dv">0</span>]
    l<span class="op">=</span>param[<span class="dv">1</span>]
    sqdist <span class="op">=</span> np.<span class="bu">sum</span>(a<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>) <span class="op">+</span> np.<span class="bu">sum</span>(b<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.dot(a, b.T)
    phi    <span class="op">=</span> np.pi<span class="op">/</span>p <span class="op">*</span> sqdist<span class="op">/</span>l
    <span class="cf">return</span>  np.exp( <span class="op">-</span><span class="dv">2</span> <span class="op">*</span> np.sin(phi)<span class="op">**</span><span class="dv">2</span>  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x<span class="op">=</span>np.linspace(xmin,xmax,n).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
plot_kernel_function(x, kernel_ESD(x,x,<span class="fl">0.5</span>)      , <span class="st">&#39; ESD ($\ell=0.5$)&#39;</span>    )
plot_kernel_function(x, kernel_RQ(x,x,[<span class="fl">0.1</span>,<span class="fl">0.5</span>]) , <span class="st">&#39; RQ ($0.1,\ell=0.5$)&#39;</span> )
plot_kernel_function(x, kernel_DP(x,x,<span class="dv">5</span>)         , <span class="st">&#39; DP ($\sigma=0.1$)&#39;</span>   )
plot_kernel_function(x, kernel_ESS(x,x,[<span class="dv">5</span>,<span class="fl">1.0</span>])  , <span class="st">&#39; ESS ($p=2,\ell=1.0$)&#39;</span>)</code></pre></div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_9_0.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_9_1.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_9_2.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_9_3.png" alt="png" />
<p class="caption">png</p>
</div>
<h2 id="priors-functions"><span class="header-section-number">1.4</span> Priors functions</h2>
<p>What happen if the procedure is performed but without any measurements? We can investigate the typical shape of the function using randomly distributed <span class="math inline">\(y_i\)</span> (with a gaussian PDF). This is exactly what is done below: this shows the prior function that will be refined once <span class="math inline">\(y_i\)</span> values comes in. The following code shows how the prior functions look like for the four different kernels discussed before.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Define 3 sets of random yi</span>
yi_random <span class="op">=</span> np.random.normal(size<span class="op">=</span>(n,<span class="dv">3</span>))

<span class="kw">def</span> plot_gp_priors(_xtest,_kernel_function, param):
    
    <span class="co"># Compute Kernel</span>
    K_11 <span class="op">=</span> _kernel_function(_xtest, _xtest, param)

    <span class="co"># Get cholesky decomposition (square root) of the covariance matrix</span>
    L <span class="op">=</span> np.linalg.cholesky( K_11 <span class="op">+</span> <span class="fl">1e-12</span><span class="op">*</span>np.eye(<span class="bu">len</span>(_xtest)) )
    
    <span class="co"># Define 5 priors based on gaussian-distributed {yi}</span>
    f_prior <span class="op">=</span> np.dot(L, yi_random)

    <span class="co"># Let&#39;s plot 3 sampled functions.</span>
    plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>,<span class="dv">5</span>))
    plt.plot(_xtest, f_prior)
    plt.xlim(np.<span class="bu">min</span>(_xtest),np.<span class="bu">max</span>(_xtest))
    plt.title(<span class="st">&#39;GP priors&#39;</span>)
    plt.tight_layout()
    
    <span class="cf">return</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Plot priors using test data</span>
xtest <span class="op">=</span> np.linspace(xmin, xmax, n).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
plot_gp_priors(xtest,kernel_ESD,<span class="fl">0.5</span>)
plot_gp_priors(xtest,kernel_RQ,[<span class="fl">0.1</span>,<span class="fl">0.5</span>])
plot_gp_priors(xtest,kernel_DP,<span class="dv">5</span>)
<span class="co">#plot_gp_priors(xtest,kernel_ESS,[8,4.0])</span></code></pre></div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_12_0.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_12_1.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_12_2.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Underlying function</span>
<span class="kw">def</span> truth_function(x):
    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>x<span class="op">*</span>np.sin(x)

<span class="co"># Noiseless training data</span>
Ndata<span class="op">=</span><span class="dv">5</span>
xtrain <span class="op">=</span> np.sort(<span class="fl">0.5</span><span class="op">*</span>(xmax<span class="op">-</span>xmin)<span class="op">*</span>np.random.rand(Ndata)<span class="op">+</span>xmin).reshape(Ndata,<span class="dv">1</span>)
ytrain <span class="op">=</span> truth_function(xtrain)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> perform_gp_prediction(_xtrain, _ytrain, _kernel_function, _param):

    <span class="co"># Apply the kernel function to our training points</span>
    K <span class="op">=</span> _kernel_function(_xtrain, _xtrain, _param)
    L <span class="op">=</span> np.linalg.cholesky( K <span class="op">+</span> <span class="fl">1e-12</span><span class="op">*</span>np.eye(<span class="bu">len</span>(_xtrain)) )
    
    <span class="co"># Compute the mean at our test points.</span>
    K_s <span class="op">=</span> _kernel_function(_xtrain, xtest, _param)
    Lk <span class="op">=</span> np.linalg.solve(L, K_s)
    mu <span class="op">=</span> np.dot(Lk.T, np.linalg.solve(L, _ytrain)).reshape((n,))
    
    <span class="co"># Compute the standard deviation so we can plot it</span>
    K_ss <span class="op">=</span> _kernel_function(xtest, xtest, _param)
    s2 <span class="op">=</span> np.diag(K_ss) <span class="op">-</span> np.<span class="bu">sum</span>(Lk<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>)
    stdv <span class="op">=</span> np.sqrt(s2)

    <span class="co"># Get function from the posterior at our test points.</span>
    L <span class="op">=</span> np.linalg.cholesky( K_ss <span class="op">+</span> <span class="fl">1e-12</span><span class="op">*</span>np.eye(n) <span class="op">-</span> np.dot(Lk.T, Lk) )
    f_post <span class="op">=</span> mu.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>) <span class="op">+</span> np.dot(L, np.random.normal(size<span class="op">=</span>(n,<span class="dv">2</span>)))

    <span class="co"># Plots things</span>
    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">6</span>))
    plt.plot(np.linspace(xmin,xmax,<span class="dv">500</span>),truth_function(np.linspace(xmin,xmax,<span class="dv">500</span>)), label<span class="op">=</span><span class="st">&#39;truth&#39;</span> )
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(f_post[<span class="dv">1</span>])):
        plt.plot(xtest, f_post[:,i], label<span class="op">=</span><span class="st">&#39;posterior n</span><span class="sc">{:.0f}</span><span class="st">&#39;</span>.<span class="bu">format</span>(i))
    plt.gca().fill_between(xtest.flat, mu<span class="op">-</span><span class="dv">2</span><span class="op">*</span>stdv, mu<span class="op">+</span><span class="dv">2</span><span class="op">*</span>stdv, color<span class="op">=</span><span class="st">&quot;#dddddd&quot;</span>, label<span class="op">=</span><span class="st">&#39;$\pm \, 1 \, \sigma$&#39;</span>)
    plt.plot(xtest, mu, <span class="st">&#39;r--&#39;</span>, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">&#39;$\mu(x)$&#39;</span>)
    plt.plot(_xtrain, _ytrain,<span class="st">&#39;o&#39;</span>, color<span class="op">=</span><span class="st">&#39;black&#39;</span>, ms<span class="op">=</span><span class="dv">10</span>, zorder<span class="op">=</span><span class="dv">10</span>, label<span class="op">=</span><span class="st">&#39;data&#39;</span>)
    plt.axis([xmin, xmax, <span class="op">-</span><span class="dv">8</span>, <span class="dv">8</span>])
    plt.title(<span class="st">&#39;Gaussian Process Interpolation&#39;</span>)
    plt.legend()
    plt.tight_layout()
    
    <span class="cf">return</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">perform_gp_prediction(xtrain,ytrain,kernel_ESD,<span class="dv">2</span>)</code></pre></div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_15_0.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">perform_gp_prediction(xtrain,ytrain,kernel_ESD,<span class="fl">0.2</span>)</code></pre></div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_16_0.png" alt="png" />
<p class="caption">png</p>
</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">perform_gp_prediction(xtrain,ytrain,kernel_RQ,[<span class="dv">4</span>,<span class="fl">0.1</span>])</code></pre></div>
<div class="figure">
<img src="GaussianProcesses_files/GaussianProcesses_17_0.png" alt="png" />
<p class="caption">png</p>
</div>
<h1 id="dark-matter-coupled-to-top-quark"><span class="header-section-number">2</span> Dark Matter Coupled to Top Quark</h1>
<h2 id="general-informations"><span class="header-section-number">2.1</span> General informations</h2>
<p><br></p>
<div style="color:red">
<p>The 2D plots need to be corrected. Right now, they seem to show the y-axis reversed (<span class="math inline">\(y=-y\)</span>).</p>
</div>
<h3 id="the-model"><span class="header-section-number">2.1.1</span> The model</h3>
<p>We consider a simplified dark matter model with a new interaction field (mediator) is responsible for the weak interaction between the ordinary matter and the introduced dark matter candidate. The particular model we are interested in relies on a coupling between dark matter and the top quark, which was designed to lead to <span class="math inline">\(t+E^{\text{miss}}_{T}\)</span>, so-called monotop final state: <a href="https://arxiv.org/abs/1407.7529"> Revisiting monotop production at the LHC (JHEP01 (2015) 017)</a>. In the non-resonant model case of this publication (on which we will focus), the general lagrangian density is:</p>
<p><span class="math display">\[
\mathcal{L}_{\mathrm{DM}} \; = \; \mathcal{L}_{\mathrm{kin}} [\chi, V_\mu] \; 
+ \;  V_\mu \, \left( \, a^{ij}_L \, \bar{u}_{i,L} \gamma^{\mu} u_{j,L} \:+\:  a^{ij}_R \, \bar{u}_{i,R} \gamma^{\mu} u_{j,R} \, \right) \;+\; V_\mu \, \left(\, g_L \, \bar{\chi}_L {\gamma^\mu} \chi_L \:+\: g_R\, \bar{\chi}_R {\gamma^\mu} \chi_R \,\right)
\]</span></p>
<p>where the matrices <span class="math inline">\(a^{ij}_L\)</span> and <span class="math inline">\(a^{ij}_R\)</span> describe the couplings in the flavour space for left-handed and right-handed components of quarks. The interaction between the dark matter and the mediator are determined by <span class="math inline">\(g_L\)</span> and <span class="math inline">\(g_R\)</span>. These parameters have a priori a real and an imaginary part.</p>
<h3 id="simplifications"><span class="header-section-number">2.1.2</span> Simplifications</h3>
<p>In order to simplify the model, we restrict the possible couplings only between the first and third generation. In addition, in order to evade <span class="math inline">\(b\)</span>-physics constraints we assume only right-handed couplings. Indeed, an interaction term with the left-handed components would automatically involve the <span class="math inline">\(b\)</span>-quark because of the <span class="math inline">\(\text{SU}(2)_{\text{L}}\)</span> symmetry, which is strongly excluded by current data. Finally, we assume vectorial interaction with the dark matter so that <span class="math inline">\(g_R=g_L\)</span>. Within these assumptions, the dynamic of the new fields is described by the following lagrangian density:</p>
<p><span class="math display">\[
\mathcal{L}_{\mathrm{DM}} \; = \;  \mathcal{L}_{\mathrm{kin}} [\chi, V_\mu] \; + \; g_{\text{SM}} \: V_\mu \: \bar{t}_R \gamma^\mu u_R \;+ \; g_{\text{DM}} \: V_\mu \: \bar{\chi} {\gamma^\mu} \chi
\]</span></p>
<p>where <span class="math inline">\(g_{\text{SM}} \equiv a^{13}_R\)</span> and <span class="math inline">\(g_{\text{DM}} \equiv g_R=g_L\)</span>. In this context, the model is fully predictive once four parameters are fixed: <span class="math inline">\((m_V,m_{\chi},g_{\text{SM}}, g_{\text{DM}})\)</span>. The new interations leads to the two additional vertices <span class="math inline">\(Vt\bar{u}\)</span> and <span class="math inline">\(V\chi\bar{\chi}\)</span> with respect to the SM.</p>
<h3 id="relevant-processes-and-final-states"><span class="header-section-number">2.1.3</span> Relevant Processes and Final States</h3>
<p>There are two experimentally interesting final states to probe this model: <span class="math inline">\(t+E^{\text{miss}}_{T}\)</span> and <span class="math inline">\(tt+X\)</span>. The first one is obtained via the process <span class="math inline">\(gu \to tV \to t\chi\bar{\chi}\)</span> while the second one can be obtained via <span class="math inline">\(gu \to tV \to tt\bar{u}\)</span> (together with two other diagrams like <span class="math inline">\(t\)</span>-channel exchange of <span class="math inline">\(V\)</span> in <span class="math inline">\(uu\to tt\)</span>). This makes the two final states complementary since they allow together to probe the model of any value of BR<span class="math inline">\(_{\chi}\)</span>.</p>
<h3 id="analytical-expressions"><span class="header-section-number">2.1.4</span> Analytical Expressions</h3>
<p>Depending on the parameter values, the signature can be then quite different and it's important to properly model these features, via for e.g. BR<span class="math inline">\(_{\chi}\)</span>. Also, for a given final state, the width of the mediator can also lead to differences in event kinematics which also need to be accounted for. The following analytical expression give the relation between the mediator properties and the model paramters at the leading order.</p>
<p><span class="math display">\[
\Gamma_{V} \; = \; \Gamma_{V\to\chi\chi} + \Gamma_{V\to t\bar{u}+\bar{t}u} ~~~~~ ; ~~~~~ \text{BR}_{\chi} \;= \; \frac{\Gamma_{V\to\chi\chi}}{\Gamma_{V}}
\]</span></p>
<p><span class="math display">\[
\Gamma_{V\to\chi\chi} \; = \; \frac{m_V}{12\pi} \: g_\text{DM}^2 \: \sqrt{1-4\frac{m^2_{\chi}}{m^2_V}} \: \left(1+2\frac{m^2_{\chi}}{m^2_V}\right) ~~~~~ ; ~~~~~ \Gamma_{V\to t\bar{u}+\bar{t}u} \; = \; \frac{m_V}{\pi}\: g_\text{SM}^2  \: \left(1-\frac{m^2_t}{m^2_V}\right) \: \left(1-\frac{m^2_t}{2m^2_V} - \frac{m^4_t}{2m^4_V}\right)
\]</span></p>
<h2 id="numerical-analysis"><span class="header-section-number">2.2</span> Numerical analysis</h2>
<h3 id="general-informations-1"><span class="header-section-number">2.2.1</span> General informations</h3>
<p>A python module, ModelParaRelation, was written in order play with the analytical formulas above, the main goal being to have a feeling of how the mediator properties are related to the model parameters. The total width as a function of mediator mass is plotted and then the evolution of the invisible BR with respect to coupling constants is also looked at. Finally, we check how the couplings constants evolves as a function of the BR.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy             <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> matplotlib        <span class="im">as</span> mpl
<span class="im">import</span> ModelParaRelation <span class="im">as</span> model
<span class="op">%</span>matplotlib inline
mV<span class="op">=</span><span class="dv">1000</span><span class="op">;</span> mDM<span class="op">=</span><span class="dv">1</span><span class="op">;</span>

<span class="co"># Ignore warning related to undefined division</span>
np.seterr(divide<span class="op">=</span><span class="st">&#39;ignore&#39;</span>, invalid<span class="op">=</span><span class="st">&#39;ignore&#39;</span>) 

<span class="co"># Plot settings</span>
mpl.rcParams[<span class="st">&#39;legend.frameon&#39;</span> ] <span class="op">=</span> <span class="va">False</span>
mpl.rcParams[<span class="st">&#39;legend.fontsize&#39;</span>] <span class="op">=</span> <span class="st">&#39;xx-large&#39;</span>
mpl.rcParams[<span class="st">&#39;xtick.labelsize&#39;</span>] <span class="op">=</span> <span class="dv">16</span>
mpl.rcParams[<span class="st">&#39;ytick.labelsize&#39;</span>] <span class="op">=</span> <span class="dv">16</span>
mpl.rcParams[<span class="st">&#39;axes.titlesize&#39;</span> ] <span class="op">=</span> <span class="dv">18</span>
mpl.rcParams[<span class="st">&#39;axes.labelsize&#39;</span> ] <span class="op">=</span> <span class="dv">18</span>
mpl.rcParams[<span class="st">&#39;lines.linewidth&#39;</span>] <span class="op">=</span> <span class="fl">2.5</span></code></pre></div>
<h3 id="mediator-width-as-function-of-its-mass"><span class="header-section-number">2.2.2</span> Mediator width as function of its mass</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gDM <span class="op">=</span> np.linspace(<span class="fl">0.1</span>,<span class="fl">1.6</span>,<span class="dv">3</span>)
gSM <span class="op">=</span> np.linspace(<span class="fl">0.1</span>,<span class="fl">1.6</span>,<span class="dv">3</span>)
g2D <span class="op">=</span> np.array( np.meshgrid(gSM,gDM) ) <span class="co"># 2D grid but 3*3 array</span>
g2D <span class="op">=</span> g2D.T                            <span class="co"># 2D grid but 3*3 transposed array</span>
g2D <span class="op">=</span> g2D.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>)                <span class="co"># 2D grid but 2*6 array --&gt; what we want</span>

<span class="co"># Mediator masses</span>
m1 <span class="op">=</span> np.linspace(model.mt<span class="op">/</span><span class="dv">5</span>, model.mt<span class="op">*</span><span class="dv">10</span>,<span class="dv">1000</span>)
m2 <span class="op">=</span> np.linspace(<span class="dv">500</span>, <span class="dv">5000</span>,<span class="dv">1000</span>)

<span class="co"># Plots</span>
plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>,<span class="dv">6</span>))
Title<span class="op">=</span><span class="st">&#39;Relative mediator width ; $m_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span> <span class="op">+</span> <span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> GeV&#39;</span>.<span class="bu">format</span>(mDM)

plt.subplot(<span class="dv">121</span>)
plt.loglog()
plt.title(Title)
plt.ylim(<span class="fl">1e-4</span>, <span class="fl">1e6</span>)
plt.ylabel(<span class="st">&#39;$\Gamma_V \,/\, m_V$&#39;</span>)
plt.xlabel(<span class="st">&#39;$m_V$ [GeV]&#39;</span>)
<span class="cf">for</span> g <span class="kw">in</span> g2D:
    gSM<span class="op">=</span>g[<span class="dv">0</span>]<span class="op">;</span>gDM<span class="op">=</span>g[<span class="dv">1</span>]
    leg_label<span class="op">=</span><span class="st">&#39;$(g_</span><span class="sc">{SM}</span><span class="st">,g_</span><span class="sc">{DM}</span><span class="st">)=$&#39;</span><span class="op">+</span><span class="st">&#39;(</span><span class="sc">{:1.1f}</span><span class="st">,</span><span class="sc">{:1.1f}</span><span class="st">)&#39;</span>.<span class="bu">format</span>(gSM,gDM)
    plt.plot(m1,model.get_total_width(gSM,gDM,m1,mDM)<span class="op">/</span>m1, label<span class="op">=</span>leg_label)
plt.legend(fontsize<span class="op">=</span><span class="st">&#39;11&#39;</span>)

plt.subplot(<span class="dv">122</span>)
plt.loglog()
plt.title(Title)
plt.ylabel(<span class="st">&#39;$\Gamma_V \,/\, m_V$&#39;</span>)
plt.xlabel(<span class="st">&#39;$m_V$ [GeV]&#39;</span>)
plt.xlim(<span class="dv">400</span>, <span class="fl">3e4</span>)
<span class="cf">for</span> g <span class="kw">in</span> g2D:
    gSM<span class="op">=</span>g[<span class="dv">0</span>]<span class="op">;</span>gDM<span class="op">=</span>g[<span class="dv">1</span>]
    leg_label<span class="op">=</span><span class="st">&#39;$(g_</span><span class="sc">{SM}</span><span class="st">,g_</span><span class="sc">{DM}</span><span class="st">)=$&#39;</span><span class="op">+</span><span class="st">&#39;(</span><span class="sc">{:1.1f}</span><span class="st">,</span><span class="sc">{:1.1f}</span><span class="st">)&#39;</span>.<span class="bu">format</span>(gSM,gDM)
    plt.plot(m2,model.get_total_width(gSM,gDM,m2,mDM)<span class="op">/</span>m2, label<span class="op">=</span>leg_label)
plt.legend(fontsize<span class="op">=</span><span class="st">&#39;11&#39;</span>)

plt.tight_layout()
plt.savefig(<span class="st">&#39;TotalWidth_vs_mV.pdf&#39;</span>)</code></pre></div>
<div class="figure">
<img src="DarkMatterModelExploration_files/DarkMatterModelExploration_10_0.png" alt="png" />
<p class="caption">png</p>
</div>
<h3 id="mediator-width-and-invisible-br-function-sm-coupling"><span class="header-section-number">2.2.3</span> Mediator width and invisible BR: function SM coupling</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gDM<span class="op">=</span>[<span class="fl">0.5</span>,<span class="dv">1</span>,<span class="fl">1.5</span>]
g <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="dv">150</span>)

plotTitle<span class="op">=</span><span class="st">&#39;$m_V=$&#39;</span><span class="op">+</span><span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> TeV&#39;</span>.<span class="bu">format</span>(mV<span class="op">/</span><span class="dv">1000</span>.) <span class="op">+</span> <span class="st">&#39; ; $m_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span> <span class="op">+</span> <span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> GeV&#39;</span>.<span class="bu">format</span>(mDM)

plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>,<span class="dv">6</span>))
plt.subplot(<span class="dv">121</span>)    
plt.title( plotTitle )
plt.xlabel(<span class="st">&#39;$g_</span><span class="sc">{SM}</span><span class="st">$&#39;</span>)
plt.ylabel(<span class="st">&#39;$\Gamma_V$ [GeV]&#39;</span>)
<span class="cf">for</span> gdm <span class="kw">in</span> gDM: plt.plot( g, model.get_total_width(g,gdm,mV,mDM) , label<span class="op">=</span><span class="st">&#39;$g_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span><span class="op">+</span><span class="st">&#39;</span><span class="sc">{:1.1f}</span><span class="st">&#39;</span>.<span class="bu">format</span>(gdm))
plt.legend()

plt.subplot(<span class="dv">122</span>)
plt.title( plotTitle )
<span class="cf">for</span> gdm <span class="kw">in</span> gDM: plt.plot( g, model.get_BR(g,gdm,mV,mDM) , label<span class="op">=</span><span class="st">&#39;$g_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span><span class="op">+</span><span class="st">&#39;</span><span class="sc">{:1.1f}</span><span class="st">&#39;</span>.<span class="bu">format</span>(gdm))
plt.xlabel(<span class="st">&#39;$g_</span><span class="sc">{SM}</span><span class="st">$&#39;</span>)
plt.ylabel(<span class="st">&#39;BR$_{\chi}$&#39;</span>)
plt.legend()

plt.tight_layout()
plt.savefig(<span class="st">&#39;SMcouplingsDep.pdf&#39;</span>)</code></pre></div>
<div class="figure">
<img src="DarkMatterModelExploration_files/DarkMatterModelExploration_12_0.png" alt="png" />
<p class="caption">png</p>
</div>
<h3 id="mediator-width-and-invisible-br-function-of-both-couplings"><span class="header-section-number">2.2.4</span> Mediator width and invisible BR: function of both couplings</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gSM     <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="dv">150</span>)
gDM     <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="dv">150</span>)
gSM,gDM <span class="op">=</span> np.meshgrid(gSM,gDM)
BR      <span class="op">=</span> model.get_BR(gSM,gDM,mV,mDM)
Gamma   <span class="op">=</span> model.get_total_width(gSM,gDM,mV,mDM)

plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>,<span class="dv">6</span>))
plotTitle<span class="op">=</span><span class="st">&#39;$m_V=$&#39;</span><span class="op">+</span><span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> TeV&#39;</span>.<span class="bu">format</span>(mV<span class="op">/</span><span class="dv">1000</span>.) <span class="op">+</span> <span class="st">&#39; ; $m_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span> <span class="op">+</span> <span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> GeV&#39;</span>.<span class="bu">format</span>(mDM)

plt.subplot(<span class="dv">121</span>)
<span class="co">#plt.pcolor(gSM, gDM, Gamma, cmap=&#39;Blues&#39;) --&gt; This makes some blank line because of the meshgrid</span>
plt.imshow(Gamma, interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>, cmap<span class="op">=</span><span class="st">&#39;Blues&#39;</span>,           <span class="co"># choose Z(x,y), interpolation and color</span>
           extent<span class="op">=</span>[gSM.<span class="bu">min</span>(), gSM.<span class="bu">max</span>(), gDM.<span class="bu">min</span>(), gDM.<span class="bu">max</span>()], <span class="co"># give proper range for x/y axis</span>
           aspect<span class="op">=</span><span class="st">&#39;auto&#39;</span>)                                       <span class="co"># fill the whole figure</span>
plt.title(<span class="st">&#39;$\Gamma_V$ [GeV] ; &#39;</span> <span class="op">+</span> plotTitle)
plt.xlabel(<span class="st">&#39;$g_</span><span class="sc">{SM}</span><span class="st">$&#39;</span>)
plt.ylabel(<span class="st">&#39;$g_</span><span class="sc">{DM}</span><span class="st">$&#39;</span>)
plt.colorbar()

plt.subplot(<span class="dv">122</span>)
plt.imshow(BR, interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>, cmap<span class="op">=</span><span class="st">&#39;Blues&#39;</span>, 
           extent<span class="op">=</span>[gSM.<span class="bu">min</span>(), gSM.<span class="bu">max</span>(), gDM.<span class="bu">min</span>(), gDM.<span class="bu">max</span>()], 
           aspect<span class="op">=</span><span class="st">&#39;auto&#39;</span> )
plt.title(<span class="st">&#39;BR$_{\chi}$ ; &#39;</span> <span class="op">+</span> plotTitle)
plt.xlabel(<span class="st">&#39;$g_</span><span class="sc">{SM}</span><span class="st">$&#39;</span>)
plt.ylabel(<span class="st">&#39;$g_</span><span class="sc">{DM}</span><span class="st">$&#39;</span>)
plt.colorbar()

plt.tight_layout()
plt.savefig(<span class="st">&#39;BRandGammavsCouplings.pdf&#39;</span>)</code></pre></div>
<div class="figure">
<img src="DarkMatterModelExploration_files/DarkMatterModelExploration_14_0.png" alt="png" />
<p class="caption">png</p>
</div>
<h3 id="mediator-couplings-as-function-of-invisible-br-and-width"><span class="header-section-number">2.2.5</span> Mediator couplings as function of invisible BR and width</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">mV<span class="op">=</span><span class="dv">1000</span><span class="op">;</span> mDM<span class="op">=</span><span class="dv">1</span><span class="op">;</span>
GV    <span class="op">=</span> np.linspace(<span class="fl">0.0</span>,<span class="dv">500</span>,<span class="dv">150</span>)
BR    <span class="op">=</span> np.linspace(<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="dv">150</span>)
GV,BR <span class="op">=</span> np.meshgrid(GV,BR)
g_SM  <span class="op">=</span> model.get_gSM_from_BRwidth(BR,GV,mV,mDM)
g_DM  <span class="op">=</span> model.get_gDM_from_BRwidth(BR,GV,mV,mDM)


plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>,<span class="dv">6</span>))
plotTitle<span class="op">=</span><span class="st">&#39;$m_V=$&#39;</span><span class="op">+</span><span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> TeV&#39;</span>.<span class="bu">format</span>(mV<span class="op">/</span><span class="dv">1000</span>.) <span class="op">+</span> <span class="st">&#39; ; $m_</span><span class="sc">{DM}</span><span class="st">=$&#39;</span> <span class="op">+</span> <span class="st">&#39;</span><span class="sc">{:.0f}</span><span class="st"> GeV&#39;</span>.<span class="bu">format</span>(mDM)

plt.subplot(<span class="dv">121</span>)
plt.imshow(g_SM, interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>, cmap<span class="op">=</span><span class="st">&#39;Blues&#39;</span>, 
           extent<span class="op">=</span>[GV.<span class="bu">min</span>(), GV.<span class="bu">max</span>(), BR.<span class="bu">min</span>(), BR.<span class="bu">max</span>()], 
           aspect<span class="op">=</span><span class="st">&#39;auto&#39;</span>)
plt.title(<span class="st">&#39;$g_</span><span class="sc">{SM}</span><span class="st">$ ; &#39;</span> <span class="op">+</span> plotTitle)
plt.xlabel(<span class="st">&#39;$\Gamma_</span><span class="sc">{V}</span><span class="st">$ [GeV]&#39;</span>)
plt.ylabel(<span class="st">&#39;BR$_{\chi}$&#39;</span>)
plt.colorbar()

plt.subplot(<span class="dv">122</span>)
plt.xlim(GV.<span class="bu">min</span>(), GV.<span class="bu">max</span>())
plt.ylim(BR.<span class="bu">min</span>(), BR.<span class="bu">max</span>())
plt.imshow(g_DM, interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>, cmap<span class="op">=</span><span class="st">&#39;Blues&#39;</span>, 
           extent<span class="op">=</span>[GV.<span class="bu">min</span>(), GV.<span class="bu">max</span>(), BR.<span class="bu">min</span>(), BR.<span class="bu">max</span>()], 
           aspect<span class="op">=</span><span class="st">&#39;auto&#39;</span>)
plt.title(<span class="st">&#39;$g_</span><span class="sc">{DM}</span><span class="st">$ ; &#39;</span> <span class="op">+</span> plotTitle)
plt.xlabel(<span class="st">&#39;$\Gamma_</span><span class="sc">{V}</span><span class="st">$ [GeV]&#39;</span>)
plt.ylabel(<span class="st">&#39;BR$_{\chi}$&#39;</span>)
plt.colorbar()

plt.tight_layout()
plt.savefig(<span class="st">&#39;BRandGammavsCouplings.pdf&#39;</span>)</code></pre></div>
<div class="figure">
<img src="DarkMatterModelExploration_files/DarkMatterModelExploration_16_0.png" alt="png" />
<p class="caption">png</p>
</div>
</body>
</html>
